<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>syscalls</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started With Syscalls</a></li><li class="chapter-item expanded "><a href="flow-to-syscall.html"><strong aria-hidden="true">2.</strong> The flow to a syscall</a></li><li class="chapter-item expanded "><a href="direct-syscalls.html"><strong aria-hidden="true">3.</strong> What is a direct syscall?</a></li><li class="chapter-item expanded "><a href="test-instruction.html"><strong aria-hidden="true">4.</strong> The test instruction</a></li><li class="chapter-item expanded "><a href="interrupts.html"><strong aria-hidden="true">5.</strong> Interrupts</a></li><li class="chapter-item expanded "><a href="indirect-syscalls.html"><strong aria-hidden="true">6.</strong> Indirect syscalls</a></li><li class="chapter-item expanded "><a href="syscall-instruction.html"><strong aria-hidden="true">7.</strong> The SYSCALL instruction</a></li><li class="chapter-item expanded "><a href="handling-syscalls.html"><strong aria-hidden="true">8.</strong> Handling syscalls</a></li><li class="chapter-item expanded "><a href="ki-system-service-repeat.html"><strong aria-hidden="true">9.</strong> KiSystemServiceRepeat</a></li><li class="chapter-item expanded "><a href="the-end.html"><strong aria-hidden="true">10.</strong> The end</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">syscalls</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started-with-syscalls"><a class="header" href="#getting-started-with-syscalls">Getting started with syscalls</a></h1>
<h2 id="what-is-a-system-call"><a class="header" href="#what-is-a-system-call">What is a system call?</a></h2>
<p>If you look online for MSDN documentation around the word syscall or system call, you might come up empty handed. You might even hit this <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/system-calls?view=msvc-170">page</a> thinking you found something of interest. Nope. Not even close. Perhaps some of the best, formal documentation is found in the Windows Internals books when describing system service calls, trapping, and overall system service handling. Windows Internals Chapter 8: System mechanics talks about this, in great detail. Something I might cover way later near the end of this thread.</p>
<p>In general, a system call is an interrupt that will interrupt the system (kernel) and invoke a service routine according to an index value. This value is what is commonly referred to as the system service call number, or system service number, or syscall ID. The kernel will handle the dispatching of the routine.</p>
<p>Perhaps the best source for this is from the Intel Software Developer Manual where it is defined that a syscall is a fast system call to privilege level 0 system procedures.</p>
<h1 id="what-generates-a-system-call"><a class="header" href="#what-generates-a-system-call">What generates a system call?</a></h1>
<p>For our purposes here in this thread, syscall is interchangeable with system call. From here on out I will just use the word syscall. These are generated by invoking the instruction <code>syscall</code> or the <code>int 2e</code> instruction. These instructions are heavily found in two low level DLLs: <code>ntdll.dll</code> and <code>win32u.dll</code>.</p>
<h1 id="where-do-syscalls-come-from"><a class="header" href="#where-do-syscalls-come-from">Where do syscalls come from?</a></h1>
<h2 id="gui-vs-native"><a class="header" href="#gui-vs-native">GUI vs Native</a></h2>
<p>Short answer: it depends. Longer answer, a syscall can from from GUI applications that depend on <code>win32u.dll</code> or Native applications where the only dependency is <code>ntdll.dll</code>.</p>
<h3 id="win32udll"><a class="header" href="#win32udll">win32u.dll</a></h3>
<p>This module is the lowest level DLL for all GUI applications or rather GUI threads to be the most technically accurate. Something that will become clearer later on is this DLL has a system call table identifier of <code>0x20</code>. This module implements many syscalls like <code>win32u!NtUserCloseClipboard</code> or <code>win32u!NtUserOpenClipboard</code>. Bottom line here is practically anything that happens from a GUI window will trickle its way down to this module.</p>
<p>On my Dev VM, my version of <code>win32u.dll</code> has 5,411 syscalls implemented.</p>
<h3 id="ntdlldll"><a class="header" href="#ntdlldll">ntdll.dll</a></h3>
<p>This module is the lowest level DLL for all native functions that are not related to GUIs. Typically you will see a native function with the two-letter prefix <code>Nt</code>, but don't be fooled, <code>Nt</code> functions are also implemented inside <code>win32u.dll</code>. Bottom line here is anything stemming from native programs, like programs that execute early on in the boot process (the session manager: <code>smss.exe</code>) will trickle its way down to this module.</p>
<p>This graphic shows a nice represenation of the flow a syscall can take depending on the process (GUI vs Native).</p>
<h1 id="how-is-a-syscall-structured"><a class="header" href="#how-is-a-syscall-structured">How is a syscall structured?</a></h1>
<h2 id="the-generic-format"><a class="header" href="#the-generic-format">The generic format</a></h2>
<p>All syscalls, no matter if they come from win32u.dll or ntdll.dll, will all have the same kind of structure. You might even think of it as a signature, a signature that can be scanned for in memory just like what is done in a lab for Day 5, or Section 5 for OnDemand students :grin:. Here is what the format looks like:</p>
<pre><code class="language-asm">4c8bd1           mov     r10, rcx
b8c3100000       mov     eax, &lt;some number here&gt;
f604250803fe7f01 test    byte ptr [7FFE0308h], 1
7503             jne     &lt;module_name&gt;!&lt;Some Nt function&gt;+0x15
0f05             syscall 
c3               ret     
cd2e             int     2Eh
c3               ret     
0f1f840000000000 nop     dword ptr [rax+rax]
</code></pre>
<p>Let's break it down a bit more...</p>
<pre><code class="language-asm">mov r10, rcx
</code></pre>
<p>For x64 CPUs and of course x64 code, the first parameter is typically found in <code>RCX</code>. You will see that <code>RCX</code> is moved into <code>R10</code> and this is obviously intentional.</p>
<h2 id="why-is-this-intentional"><a class="header" href="#why-is-this-intentional">Why is this intentional?</a></h2>
<p>Because the code can eventually execute the <code>syscall</code> instruction, it has to get rid of the <code>RCX</code> value and move it into <code>R10</code>. Further, <code>syscall</code> will destroy the <code>RCX</code> register and load it with the return address. If the <code>MOV</code> is not done, the first parameter will be lost. You can't use <code>R11</code> either since it will be clobbered by <code>syscall</code> so the last best option was <code>R10</code> to hold the first parameter as code transitions into Ring 0.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What's next?</a></h2>
<p>Let's continue breaking it down...</p>
<pre><code class="language-asm">mov     eax, &lt;some number here&gt;
</code></pre>
<p><code>&lt;some number here&gt;</code> will be reserved for the number of the syscall to be "called". Again, this is really an index into a table that we can take a look at later in this series of threads using a kernel debugger.</p>
<p>Here is one full example for a syscall from win32u.dll:</p>
<pre><code class="language-asm">4c8bd1           mov     r10, rcx
b8c3100000       mov     eax, 10C3h
</code></pre>
<p>For the function <code>win32u!NtUserOpenClipboard</code> the above number is tied to that function.</p>
<p>I'm going to skip...</p>
<pre><code class="language-asm">test    byte ptr [7FFE0308h], 1
jne     &lt;module_name&gt;!&lt;Some Nt function&gt;+0x15
</code></pre>
<p>... for now just because that is getting too deep too soon for where I want this thread.</p>
<p>The next thing that will happen is that <code>syscall</code> will be executed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-flow-to-a-syscall"><a class="header" href="#the-flow-to-a-syscall">The flow to a syscall</a></h1>
<h2 id="native-processes"><a class="header" href="#native-processes">Native processes</a></h2>
<p>We already saw a very high level graphic depicting the flow for syscalls, but now let's dive into a real example on the native side of things, since that's the most common in our world of implant dev.</p>
<h2 id="allocating-memory"><a class="header" href="#allocating-memory">Allocating memory</a></h2>
<p>Let's say that you want to allocate a page or so of memory for shellcode execution or the manual mapping of a COFF object, EXE image or DLL image. To do so, you'd have to call <code>VirtualAlloc</code> (staying inside the local process), the highest level API we can call, implemented in <code>kernelbase.dll</code>, but ultimately forwarded to <code>ntdll.dll</code>.</p>
<p>Let's check it out on the C-side.</p>
<pre><code class="language-cpp">INT
__cdecl
main(VOID)
{
  // alloc a single page
  LPVOID pBuffer = VirtualAlloc(NULL, PAGE_SIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
  // error check here
  // do shady things
  // cleanup, overwrite with garbage data
  VirtualFree(..);
  pBuffer = LPVOID();
  // go home
  return ERROR_SUCCESS;
}
</code></pre>
<p>It's a simple program that allocates one page of memory. Now we can follow this in WinDbg... the best debugger on the planet.</p>
<p>I launched a new executable under WinDbg and set a BP on <code>kernelbase!VirtualAlloc</code> using the command: <code>bp kernelbase!VirtualAlloc</code></p>
<p>F5 the program and let the BP hit.</p>
<p>The BP will get hit and at that time you can see what calls it makes. We are looking for some <code>Nt</code> prefixed function in the output.</p>
<pre><code class="language-text">0:000&gt; uf /c kernelbase!VirtualAlloc
KERNELBASE!VirtualAlloc (00007ffc`b1bb18a0)
  KERNELBASE!VirtualAlloc+0x41 (00007ffc`b1bb18e1):
    // bingo!
    call to ntdll!NtAllocateVirtualMemory (00007ffc`b402d060)
  KERNELBASE!VirtualAlloc+0x5e (00007ffc`b1bb18fe):
    call to KERNELBASE!BaseSetLastNTError (00007ffc`b1b7b300)
  KERNELBASE!VirtualAlloc+0x4e30d (00007ffc`b1bffbad):
    call to ntdll!RtlSetLastWin32Error (00007ffc`b3fe0770)
</code></pre>
<p>Cool. Now we can jump into NTDLL and take a look from there.</p>
<p>From here, set a <code>BP</code> on that routine or just hit <code>TC</code> to trace to the first call instruction found.</p>
<p>Here is what things will look like at the <code>BP</code>.</p>
<pre><code class="language-text">ntdll!NtAllocateVirtualMemory:
00007ffc`b402d060 4c8bd1           mov     r10, rcx. // &lt;--- first param
00007ffc`b402d063 b818000000       mov     eax, 18h  // &lt;--- syscall number
00007ffc`b402d068 f604250803fe7f01 test    byte ptr [7FFE0308h], 1
00007ffc`b402d070 7503             jne     ntdll!NtAllocateVirtualMemory+0x15 (7ffcb402d075)
00007ffc`b402d072 0f05             syscall 
00007ffc`b402d074 c3               ret     
00007ffc`b402d075 cd2e             int     2Eh
00007ffc`b402d077 c3               ret     
00007ffc`b402d078 0f1f840000000000 nop     dword ptr [rax+rax]
</code></pre>
<p>You can continue to single step up to the <code>syscall</code> if you'd like. You won't be able to jump with the <code>syscall</code> into the kernel just yet, but we will dive into that later and take this all the way home!</p>
<p>One thing I like to check out around this time is the call stack. Run <code>k</code> to show the call stack up to this point.</p>
<pre><code class="language-text">0:000&gt; k
 # Child-SP          RetAddr               Call Site
00 000000f4`8970fb18 00007ffc`b1bb18e8     ntdll!NtAllocateVirtualMemory
01 000000f4`8970fb20 00007ff7`63a91e84     KERNELBASE!VirtualAlloc+0x48
[..SNIP..]
05 000000f4`8970fb60 00007ff7`63a9408c     Shellcode!main+0x254
[..SNIP..]
07 000000f4`8970fc80 00007ffc`b3fe2651     KERNEL32!BaseThreadInitThunk+0x14
08 000000f4`8970fcb0 00000000`00000000     ntdll!RtlUserThreadStart+0x21
</code></pre>
<p>Cool. Now we can start to dive a bit deeper into things over the next several chapters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-direct-syscall"><a class="header" href="#what-is-a-direct-syscall">What is a direct syscall?</a></h1>
<p>Over in <a href="./flow-to-syscall.html">The flow to a syscall</a>, you see what are viewed as wrappers that wrap around direct syscalls. Some of the wrapping could be seen as bloat or unwanted overhead in a program. Also, those wrapper routines can be subject to user mode hooks, but let's leave hooks out of this for now.</p>
<p>An option that can be done is to avoid those wrapper functions that are typically found in <code>kernel32.dll</code> and <code>kernelbase.dll</code>, to name a few, and just go directly to the <code>syscall</code> itself in <code>ntdll.dll</code>. This action is how the technique named <strong>direct syscalls</strong> was born. Skip all of the higher level stuff and go directly to the lowest level possible.</p>
<h2 id="syscall-stub"><a class="header" href="#syscall-stub">Syscall stub</a></h2>
<p>We have already seen the format of a <code>syscall</code> and many folks simply call it a <strong>stub</strong> that prepares for the transition from ring 3 to ring 0, since a Windows installation only configures Intel CPUs to use those two rings (there are rings 1 and 2). The transition of rings is not done until the <code>syscall</code> instruction is executed. At that point in time, user mode code is left behind and the system will make the transition from ring 3 to ring 0. This will also change something called the <strong>Current Privilege Level</strong> (CPL) to 0.</p>
<h2 id="the-syscall-stub-pattern"><a class="header" href="#the-syscall-stub-pattern">The syscall stub pattern</a></h2>
<p>When implant developers want to perform a direct syscall, many times a search is implemented looking for the following sequence of bytes:</p>
<pre><code class="language-text">// the start of the syscall stub
4c 8b d1 XX XX 00 00 

// the end of the stub
0f 05 c3 cd 2e c3
</code></pre>
<p>At the root of it, that is not really a complete stub, but on some older versions of Windows and ntdll.dll, it is. On more recent versions of Windows, there are some missing instructions from what is shown above. Those missing instructions are the following:</p>
<pre><code class="language-asm">test    byte ptr [7FFE0308h], 1
jne     ntdll!&lt;Some Nt Function&gt;+0x15
</code></pre>
<p>Let's dive into those instructions in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-test-instruction"><a class="header" href="#the-test-instruction">The test instruction</a></h1>
<h2 id="what-is-at-address-7ffe0308h"><a class="header" href="#what-is-at-address-7ffe0308h">What is at address <code>7FFE0308h</code>?</a></h2>
<p>For those who have sat the class, you know exactly what that address is. For those that haven't sat that class, this is looking into an undocumented structure. If you look at <code>308h</code> as an offset into a <code>struct</code>, you'd be left with <code>7FFE0000h</code>. That user mode address is the static memory location for the <strong><code>_KUSER_SHARED_DATA</code></strong> struct. Here is a small snippet of that struct dumped from WinDbg on a Windows 10 system without Virtual Based Security enabled.</p>
<pre><code class="language-text">0: kd&gt; dt ntdll!_KUSER_SHARED_DATA 0x7ffe0000
   +0x000 TickCountLowDeprecated 0 : Uint4B
   +0x004 TickCountMultiplier 0xfa00000 : Uint4B
   +0x008 InterruptTime    : _KSYSTEM_TIME
   +0x014 SystemTime       : _KSYSTEM_TIME
   +0x020 TimeZoneBias     : _KSYSTEM_TIME
   +0x02c ImageNumberLow   0x8664 : Uint2B
   +0x02e ImageNumberHigh  0x8664 : Uint2B
   +0x030 NtSystemRoot     "C:\Windows": [260] Wchar
[...SNIP...]
   +0x308 SystemCall      0 : Uint4B
</code></pre>
<p>It's a massive structure that is often abused by exploit devs and implant devs. One of the interesting fields is at offset <code>308h</code>, <strong>SystemCall</strong>.</p>
<h2 id="_kuser_shared_datasystemcall"><a class="header" href="#_kuser_shared_datasystemcall"><code>_KUSER_SHARED_DATA.SystemCall</code></a></h2>
<p>Back in the day, this field used to hold the address that was going to be executed in the kernel. This became abused and now the meaning has changed for it. Currently, the value will be either clear (0) or set (1), and is a way to detect if <strong>Virtual Based Security</strong> is enabled for a system. If it is, then the <code>TEST</code> instruction will result in <strong>TRUE</strong>, the <strong>EFLAGS</strong> will be updated accordingly, and the <code>JMP</code> will be taken. The <code>JMP</code> will then land on the <code>INT 2Eh</code> instruction. This also means that there are <strong>Virtual Trust Levels</strong> and the syscalls will now happen in <strong>VTL0</strong>.</p>
<p>The true enthusiasts out there might be curious to know the speeds behind these instructions. The <code>SYSCALL</code> instruction is measurably faster than <code>INT 2Eh</code> by ~1.00 clock ticks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts"><a class="header" href="#interrupts">Interrupts</a></h1>
<h2 id="what-is-int-2eh"><a class="header" href="#what-is-int-2eh">What is INT 2Eh?</a></h2>
<p>The <strong>INT</strong> instruction invokes something called an <strong>interrupt</strong> that kind of "halts" the system to "wake up" the kernel's interrupt handler routine. The value given to the instruction is an index into a table called the <strong>Interrupt Descriptor Table</strong>, or <strong>IDT</strong>. Every system is going to have one of these tables and you can see them with a kernel debugging session. Here is a dump of the IDT on a Windows 10 Dev-VM built for SEC670.</p>
<pre><code class="language-text">0: kd&gt; !idt
Dumping IDT: fffff804774f2000
00:    fffff80474a13800 nt!KiDivideErrorFault
[..SNIP..]
03:    fffff80474a14500 nt!KiBreakpointTrap
[..SNIP..]
1f:    fffff80474a0ce40 nt!KiApcInterrupt
[..SNIP..]
2f:    fffff80474a0efe0 nt!KiDpcInterrupt
</code></pre>
<p>There are some interesting ones there in this snippet like dividing by 0, a breakpoint getting hit, APC interrupts, DPC interrupts. Whenever one of those events happen, like a divide by 0, an interrupt will be triggered and INT 00h will be the underlying entry for that. You can also see the address of the routine that will handle an interrupt. Back in the day, people loved to hook entries in the IDT, but that's not really a thing anymore.</p>
<p>What's missing from the above snippet is the entry <strong>2Eh</strong>. This one is missing because even though Hyper-V is enabled, VBS is not. Thus, there will be no corresponding entry for it built into the table. It will never get hit and there's no need to have a handler routine for it. Simple as that.</p>
<h2 id="building-the-idt"><a class="header" href="#building-the-idt">Building the IDT</a></h2>
<p>The IDT is built when the kernel is being initialized in the routine <strong><code>nt!KiInitializeKernel</code></strong>. Also in that massive routine, the <code>_KUSER_SHARED_DATA</code> structure is filled out by the <strong><code>nt!KiInitializeBootStructures</code></strong> routine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indirect-syscalls"><a class="header" href="#indirect-syscalls">Indirect syscalls</a></h1>
<h2 id="cons-of-direct-syscalls"><a class="header" href="#cons-of-direct-syscalls">Cons of direct syscalls</a></h2>
<p>As a refresher, direct syscalls are being invoked from within our own EXE. Cool, we can maybe get past some EDRs but there is a downside to this. We can be caught because the return address is not going to be located where it should be; ntdll.dll. This check can happen when the kernel is done doing its thing. Inside the <strong><code>_KPROCESS.InstrumentationCallback</code></strong> field, is a pointer to the routine that will be invoked after the <code>SYSCALL</code> is done (<code>SYSRET</code>). The check can be quite simple and if you know how to parse a PE image, then I'm sure you can already think of the simple 3 or so lines of C++ code to get that done, like so:</p>
<pre><code class="language-cpp">const auto ImageBase = NtCurrentPeb()-&gt;ImageBaseAddress;
const auto NtHeaders = RtlImageNtHeader(ImageBase);
if ((retaddr &gt;= ImageBase) &amp;&amp; (retaddr &lt; ImageBase + NtHeaders-&gt;OptionalHeader.SizeOfImage))
{
    // retaddr is within the EXE
}
</code></pre>
<h2 id="what-are-indirect-syscalls"><a class="header" href="#what-are-indirect-syscalls">What are indirect syscalls?</a></h2>
<p>Instead of having the <code>SYSCALL</code> instruction coming from within our own EXE's image, we need to have it come from within NTDLL. Like any normal <code>SYSCALL</code> would look like. To help with this, <strong>Bouncy Gate</strong> and <strong>Recycled Gate</strong> were made. There are too many gates.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>Here, instead of calling the <code>SYSCALL</code> ourselves, we <strong>jump</strong> to it. We find the address of the <code>SYSCALL</code> instruction inside of NTDLL and <code>JMP</code> there. <code>JMP</code>s and <code>CALL</code>s are indirect instructions. In addition to the gates mentioned above, <strong>SysWhispers3</strong> also uses indirect syscalls, just like <strong>Cobalt Strike's BOFs</strong> do too.</p>
<h2 id="cons-about-indirect-syscalls"><a class="header" href="#cons-about-indirect-syscalls">Cons about indirect syscalls</a></h2>
<p>One of the downsides is that EDRs are catching on here. In addition to checking the return address of them, they are now looking at where they came from, EXE or NTDLL. So now, we have to fake where they are coming from with a new thread and then spoofing the call stack.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-syscall-instruction"><a class="header" href="#the-syscall-instruction">The <code>SYSCALL</code> instruction</a></h1>
<h2 id="lets-get-stuck-in"><a class="header" href="#lets-get-stuck-in">Let's get stuck in</a></h2>
<p>The absolute best place to understand what is really happening with this instruction is to look at the Intel manual for it. Let's take a look at this right from there:</p>
<blockquote>
<p>"SYSCALL invokes an OS system-call handler at privilege level 0. It does so by loading RIP from the IA32_LSTAR MSR (after saving the address of the instruction following SYSCALL into RCX). (The WRMSR instruction ensures that the IA32_LSTAR MSR always contain a canonical address.)"</p>
</blockquote>
<h2 id="things-to-note"><a class="header" href="#things-to-note">Things to note</a></h2>
<p>OK, so we have some things to take away from that:</p>
<ul>
<li><strong>System-call handler</strong></li>
<li><strong>IA32_LSTAR MSR</strong></li>
<li><strong>Return address saved in RCX</strong></li>
</ul>
<p>Let's keep going:</p>
<blockquote>
<p>"SYSCALL also saves RFLAGS into R11 and then masks RFLAGS using the IA32_FMASK MSR (MSR address C0000084H); specifically, the processor clears in RFLAGS every bit corresponding to a bit that is set in the IA32_FMASK MSR. SYSCALL loads the CS and SS selectors ..."</p>
</blockquote>
<p>OK, that isn't entirely useful anymore. We have what we need to move on with this.</p>
<h2 id="system-call-handler"><a class="header" href="#system-call-handler">System-call handler</a></h2>
<p>From the notes above, we need to know what this routine is if we want to dive into this any deeper. To find out what the handler is for <strong>IA32_LSTAR MSR</strong>, we need to be in a kernel debugger session. We then need to use a <strong>CPL0</strong>-only instruction to read from the <strong>MSR</strong>: <strong><code>rdmsr</code></strong>. In a kernel driver, the equivalent would be a compiler intrinsic <strong><code>__readmsr</code></strong>.</p>
<pre><code class="language-text">0: kd&gt; rdmsr C0000082H
msr[c0000082] = fffff804`74a1a2c0
</code></pre>
<p>We now have the address of the system-call handler, but what is it really? Let's find out back in WinDbg. To do this, we want to use the <strong><code>ln</code></strong> command to list the nearest symbol at that address.</p>
<pre><code class="language-text">0: kd&gt; ln fffff804`74a1a2c0
Browse module
Set bu breakpoint

(fffff804`74a1a2c0)   nt!KiSystemCall64   |  (fffff804`74a1a500)   nt!KiSystemServiceUser
Exact matches:
</code></pre>
<p>For this remote system, VBS is not enabled and as such, the handler is <strong><code>nt!KiSystemCall64</code></strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-syscalls"><a class="header" href="#handling-syscalls">Handling syscalls</a></h1>
<h2 id="discovering-the-syscall-handler"><a class="header" href="#discovering-the-syscall-handler">Discovering the syscall handler</a></h2>
<p>From the previous chapter, <a href="./syscall-instruction.html">The SYSCALL instruction</a>, we saw how to obtain the handler that services all syscalls coming from userland. Since we still have a kernel debugging session up and running, we can disassemble the function and also set a breakpoint on it.</p>
<h2 id="breakpoints"><a class="header" href="#breakpoints">Breakpoints</a></h2>
<p>The first instinct might have you set a BP right at the function itself like so: <strong><code>bp nt!KiSystemCall64</code></strong>. Not a bad idea at first and I did this as well. After BSODing my VM a few times after setting that BP, I realized that this isn't your normal function with a proper function prolog. Typically, a proper function prolog will set up the stack frame, make sure <code>RSP</code> is taken care of before execution of that function proceeds.</p>
<p>The first instruction here is a <strong><code>SWAPGS</code></strong> which is insanely critical for syscall handling and is also the reason the VM becomes unstable and ultimately BSODs when setting a BP on that instruction. After a bit more experimentation, I found that setting a BP at <strong><code>nt!KiSystemCall64+15h</code></strong> was more stable and reliable.</p>
<p>Let's look at the first several instructions for the syscall handler on this VM.</p>
<pre><code class="language-text">nt!KiSystemCall64:
0f01f8                         swapgs      // BP here crashes the VM
654889242510000000             mov     qword ptr gs:[10h], rsp
65488b2425a8010000             mov     rsp, qword ptr gs:[1A8h]
6a2b                           push    2Bh  // BP here, all is good!
</code></pre>
<h2 id="setting-up-rsp"><a class="header" href="#setting-up-rsp">Setting up <code>RSP</code></a></h2>
<p>If you look at the disassembly, you will see that <code>RSP</code> isn't properly set up until the second <code>MOV</code> instruction: <strong><code>MOV RSP, QWORD PTR GS:[1A8h]</code></strong>. This is why setting a BP any time before, or even on that instruction, creates instability. At the first <code>MOV</code> instruction, <code>RSP</code> will still be pointing to a userland address. This is not good now that we are in the kernel with CPL0. The offsets you see for the GS segment register won't really make sense yet. For that, I will dedicate a chapter for the <strong>SWAPGS</strong> instruction next.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kisystemservicerepeat"><a class="header" href="#kisystemservicerepeat">KiSystemServiceRepeat</a></h1>
<h2 id="the-purpose"><a class="header" href="#the-purpose">The purpose</a></h2>
<p>At some point, the code flow will make its way down to <strong><code>KiSystemServiceRepeat</code></strong> after the trap frame has been established in <strong><code>KiSystemServiceStart</code></strong>. One of the first things <code>KiSystemServiceRepeat</code> does is grab pointers to 2 of 3 arrays that are used to keep track of system service tables. The 3 arrays are <strong><code>KeServiceDescriptorTable</code></strong>, <strong><code>KeServiceDescriptorTableShadow</code></strong>, and <strong><code>KeServiceDescriptorTableFilter</code></strong>. Inside each of the tables, there will be a couple of entries where each entry will hold some useful information like the following:</p>
<ul>
<li>A pointer to the array of system calls that are implemented in that table</li>
<li>How many system calls are present in that table</li>
<li>A pointer to an array of byte arguments for each of the system calls in that table</li>
</ul>
<p>Like most things, this data is held within a structure called <strong><code>_SYSTEM_SERVICE_TABLE</code></strong>.</p>
<pre><code class="language-cpp">typedef struct _SYSTEM_SERVICE_TABLE {
    PULONG      ServiceTable;   // pointer to array of system calls in this table
    PULONG_PTR  CounterTable;
    ULONG_PTR   ServiceLimit;   // how many system calls are present in this table
    PBYTE       ArgumentTable;  // pointer to array of byte arguments for each system call
} SYSTEM_SERVICE_TABLE;
</code></pre>
<h2 id="argument-table"><a class="header" href="#argument-table">Argument table</a></h2>
<p>The argument table is very important. Its purpose is to tell the kernel how many arguments it needs to find on the user-mode stack. It will then take those arguments and bring them into the kernel's stack.</p>
<h2 id="in-the-debugger"><a class="header" href="#in-the-debugger">In the debugger</a></h2>
<p>In the kernel debugger, you can easily dump the table and see the pointers as well as some of the other data from the structs. First off, grab the address of the table: <strong><code>x nt!KiServiceTable</code></strong>. You can use that symbol and index your way into the table to find things like arguments for a syscall. Like so:</p>
<pre><code class="language-text">dx (((int*)&amp;(nt!KiServiceTable))[1] &amp; 0xf)
(((int*)&amp;(nt!KiServiceTable))[1] &amp; 0xf) : 0

dx (((int*)&amp;(nt!KiServiceTable))[2] &amp; 0xf)
(((int*)&amp;(nt!KiServiceTable))[2] &amp; 0xf) : 2  // 2 stack args
</code></pre>
<p>It's quite a manual process doing that especially if there are hundreds of syscalls in that table. It would be much better to use the true power of WinDbg and its debugger data model like so:</p>
<pre><code class="language-text">// make a pseudo variable
dx @$table = &amp;nt!KiServiceTable
@$table = &amp;nt!KiServiceTable : 0xfffff8012dee4eb0 [Type: void *]
// dump the table and shift right by 4, then add to base of the table
dx (((int(*)[90000])&amp;(nt!KiServiceTable)))-&gt;Take(*(int*)&amp;nt!KiServiceLimit)-&gt;Select(x =&gt; (x &gt;&gt; 4) + @$table)
    [0]              : 0xfffff8012e14b650 [Type: void *]
    [1]              : 0xfffff8012e155ce0 [Type: void *]
    [2]              : 0xfffff8012e506e10 [Type: void *]
    [3]              : 0xfffff8012e6f1640 [Type: void *]
    [4]              : 0xfffff8012e435a40 [Type: void *]
    [5]              : 0xfffff8012e218710 [Type: void *]
    [6]              : 0xfffff8012e419f60 [Type: void *]
</code></pre>
<p>The above output is cool and all but we can do better. The pointers can be resolved and we can see what lies behind them; the syscalls!</p>
<p>Let's again leverage the number of syscalls in the table (<code>ServiceLimit</code>) and dump everything, but then resolve the symbolic names.</p>
<pre><code class="language-text">dx (((int(*)[90000])&amp;(nt!KiServiceTable)))-&gt;Take(*(int*)&amp;nt!KiServiceLimit)-&gt;Select(x =&gt; @$dumpit((x &gt;&gt; 4) + @$table))
    [0]              : nt!NtAccessCheck (fffff801`2e14b650)
    [1]              : nt!NtWorkerFactoryWorkerReady (fffff801`2e155ce0)
    [2]              : nt!NtAcceptConnectPort (fffff801`2e506e10)
    [3]              : nt!NtMapUserPhysicalPagesScatter (fffff801`2e6f1640)
    [4]              : nt!NtWaitForSingleObject (fffff801`2e435a40)
    [5]              : nt!NtCallbackReturn (fffff801`2e218710)
    [6]              : nt!NtReadFile (fffff801`2e419f60)
</code></pre>
<p>Reminder: this is only the table for service syscalls that come from <code>ntdll.dll</code> and <strong>NOT</strong> from <code>win32u.dll</code> into <code>win32k.sys</code>.</p>
<p>I leave that as an exercise to you all!</p>
<h2 id="checking-the-syscall-index"><a class="header" href="#checking-the-syscall-index">Checking the syscall index</a></h2>
<p>One of the next actions <code>KiSystemServiceRepeat</code> does is check to see if the syscall index is beyond this table. Remember, every table has a <code>ServiceLimit</code> that indicates how many syscalls there are. Let's see how it computes this in code.</p>
<pre><code class="language-asm">cmp eax, [r10+rdi+10h]
</code></pre>
<p><code>EAX</code> holds the syscall index. <code>R10</code> holds the table. <code>RDI</code> holds the table ID which could be one of four values from 00b to 11b. Obviously 10h is just 16 in decimal. So, the check here is accessing an offset into the <code>KeServiceDescriptorTable</code> to find the <code>ServiceLimit</code>.</p>
<pre><code class="language-text">dps nt!KeServiceDescriptorTable
fffff801`2ec1e8c0  fffff801`2dee4eb0 nt!KiServiceTable
fffff801`2ec1e8c8  00000000`00000000
fffff801`2ec1e8d0  00000000`000001d7  // this is the ServiceLimit
fffff801`2ec1e8d8  fffff801`2dee5610 nt!KiArgumentTable
</code></pre>
<p>This can be validated because the <code>ServiceLimit</code> is a global symbol so check it out.</p>
<pre><code class="language-text">dc nt!KiServiceLimit l1
fffff801`2dee560c  000001d7  // it's a match!!
</code></pre>
<p>After this check, a jump will be taken if it's out of range, meaning it is not in this table. Then when it jumps, the thread will be converted to a GUI thread by calling <strong><code>KiConvertToGuiThread</code></strong>. This is what that code block looks like:</p>
<pre><code class="language-asm">mov     [rbp-80h], eax
mov     [rbp-78h], rcx
mov     [rbp-70h], rdx
mov     [rbp-68h], r8
mov     [rbp-60h], r9
call    KiConvertToGuiThread
or      eax, eax
mov     eax, [rbp-80h]
mov     rcx, [rbp-78h]
mov     rdx, [rbp-70h]
mov     r8, [rbp-68h]
mov     r9, [rbp-60h]
mov     [rbx+90h], rsp
jz      KiSystemServiceRepeat   // start the process all over after the conversion
</code></pre>
<p>Eventually, the jump will not be taken and we will wind up in this code block:</p>
<pre><code class="language-asm">// KeServiceDescriptorTable + tableID (00h or 20h) = nt!KiServiceTable
mov     r10, [r10+rdi]
// movsxd will move a 32-bit number into 64-bit register keeping the sign
// so negative number will stay negative
// nt!KiServiceTable + syscallIndex * 4
// syscall index 23h - NtQueryVirtualMemory
// dd /c1 nt!KiServiceTable + 23h * 4 l1 = fffff801`14cdcf3c  0557bd02 &lt;-- RVA!
movsxd  r11, dword ptr [r10+rax*4]
// RAX - RVA of syscall - 0557bd02
</code></pre>
<p>This RVA is interesting. The first byte holds the number of stack args. In this instance, it says 2. So, the kernel will be copying 2 values from the user mode stack. This is why the RVA is shifted right by 4 bits, to skip over this value.</p>
<pre><code class="language-asm">mov     rax, r11
// RVA &gt;&gt; 4 = 557bd0
sar     r11, 4
// nt!KiServiceTable + RVA = fffff801`15234a80
// ln fffff801`15234a80
// (fffff801`15234a80) nt!NtQueryVirtualMemory &lt;-- found it!!
add     r10, r11
cmp     edi, 20h ; ' '
jnz     short loc_140408ED0
</code></pre>
<p>After a few more checks are done, the syscall is eventually invoked using an indirect call like this:</p>
<pre><code class="language-asm">mov rax, r10
call rax
</code></pre>
<p>At this time, all the proper registers RCX, RDX, R8, R9 have been populated with the proper syscall args, and the user mode stack was copied to the kernel stack.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-end"><a class="header" href="#the-end">The end</a></h1>
<h2 id="thanks-for-sticking-with-me"><a class="header" href="#thanks-for-sticking-with-me">Thanks for sticking with me</a></h2>
<p>Thanks a ton for sticking with me through this journey of an incredible deep dive into syscalls. If you follow along in a kernel debugger, you will have truly mastered the entire flow from user mode to kernel mode.</p>
<p>I hope you learned something along the way!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
